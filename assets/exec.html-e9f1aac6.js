import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as l,c,d as e,b as a,w as n,e as t,f as d}from"./app-8b62c3ab.js";const r={},u=d(`<h1 id="exec" tabindex="-1"><a class="header-anchor" href="#exec" aria-hidden="true">#</a> <code>exec</code></h1><blockquote><p>Runs an executable</p></blockquote><h2 id="description" tabindex="-1"><a class="header-anchor" href="#description" aria-hidden="true">#</a> Description</h2><p>With Murex, like most other shells, you launch a process by calling the name of that executable directly. While this is suitable 99% of the time, occasionally you might run into an edge case where that wouldn&#39;t work. The primary reason being if you needed to launch a process from a variable, eg</p><pre><code>» set exe=uname
» $exe
uname
</code></pre><p>As you can see here, Murex&#39;s behavior here is to output the contents of the variable rather then executing the contents of the variable. This is done for safety reasons, however if you wanted to override that behavior then you could prefix the variable with exec:</p><pre><code>» set exe=uname
» exec $exe
Linux
</code></pre><h2 id="usage" tabindex="-1"><a class="header-anchor" href="#usage" aria-hidden="true">#</a> Usage</h2><pre><code>\`&lt;stdin&gt;\` -&gt; exec
\`&lt;stdin&gt;\` -&gt; exec -&gt; \`&lt;stdout&gt;\`
           exec -&gt; \`&lt;stdout&gt;\`
</code></pre><h2 id="examples" tabindex="-1"><a class="header-anchor" href="#examples" aria-hidden="true">#</a> Examples</h2><pre><code>» exec printf &quot;Hello, world!&quot;
Hello, world!
</code></pre><p><strong>Working around aliases:</strong></p><p>If you have an alias like <code>alias ls=ls --color=auto</code> and you wanted to run <code>ls</code> but without colour, you might run <code>exec ls</code>.</p><h2 id="detail" tabindex="-1"><a class="header-anchor" href="#detail" aria-hidden="true">#</a> Detail</h2><p>If any command doesn&#39;t exist as a builtin, function nor alias, then Murex will default to forking out to any command with this name (subject to an absolute path or the order of precedence in <code>$PATH</code>). Any forked process will show up in both the operating systems process viewer (eg <code>ps</code>) but also Murex&#39;s own process viewer, <code>fid-list</code>. However inside <code>fid-list</code> you will notice that all external processes are listed as <code>exec</code> with the process name as part of <code>exec</code>&#39;s parameters. That is because <code>exec</code> is handler for programs that aren&#39;t native to Murex.</p><h3 id="compatibility-with-posix" tabindex="-1"><a class="header-anchor" href="#compatibility-with-posix" aria-hidden="true">#</a> Compatibility with POSIX</h3><p>For compatibility with traditional shells like Bash and Zsh, <code>command</code> is an alias for <code>exec</code>.</p><h2 id="synonyms" tabindex="-1"><a class="header-anchor" href="#synonyms" aria-hidden="true">#</a> Synonyms</h2><ul><li><code>exec</code></li><li><code>command</code></li></ul><h2 id="see-also" tabindex="-1"><a class="header-anchor" href="#see-also" aria-hidden="true">#</a> See Also</h2>`,20),h=e("code",null,"bexists",-1),m=e("code",null,"bg",-1),f=e("code",null,"builtins",-1),x=e("code",null,"fexec",-1),p=e("code",null,"fg",-1),_=e("code",null,"fid-kill",-1),b=e("code",null,"fid-killall",-1),g=e("em",null,"all",-1),y=e("code",null,"fid-list",-1),w=e("code",null,"jobs",-1),k=e("code",null,"murex-update-exe-list",-1),v=e("code",null,"set",-1);function M(T,A){const o=s("RouterLink");return l(),c("div",null,[u,e("ul",null,[e("li",null,[a(o,{to:"/commands/bexists.html"},{default:n(()=>[h]),_:1}),t(": Check which builtins exist")]),e("li",null,[a(o,{to:"/commands/bg.html"},{default:n(()=>[m]),_:1}),t(": Run processes in the background")]),e("li",null,[a(o,{to:"/commands/runtime.html"},{default:n(()=>[f]),_:1}),t(": Returns runtime information on the internal state of Murex")]),e("li",null,[a(o,{to:"/commands/fexec.html"},{default:n(()=>[x]),_:1}),t(": Execute a command or function, bypassing the usual order of precedence.")]),e("li",null,[a(o,{to:"/commands/fg.html"},{default:n(()=>[p]),_:1}),t(": Sends a background process into the foreground")]),e("li",null,[a(o,{to:"/commands/fid-kill.html"},{default:n(()=>[_]),_:1}),t(": Terminate a running Murex function")]),e("li",null,[a(o,{to:"/commands/fid-killall.html"},{default:n(()=>[b]),_:1}),t(": Terminate "),g,t(" running Murex functions")]),e("li",null,[a(o,{to:"/commands/fid-list.html"},{default:n(()=>[y]),_:1}),t(": Lists all running functions within the current Murex session")]),e("li",null,[a(o,{to:"/commands/fid-list.html"},{default:n(()=>[w]),_:1}),t(": Lists all running functions within the current Murex session")]),e("li",null,[a(o,{to:"/commands/murex-update-exe-list.html"},{default:n(()=>[k]),_:1}),t(": Forces Murex to rescan $PATH looking for executables")]),e("li",null,[a(o,{to:"/commands/set.html"},{default:n(()=>[v]),_:1}),t(": Define a local variable and set it's value")])])])}const R=i(r,[["render",M],["__file","exec.html.vue"]]);export{R as default};
