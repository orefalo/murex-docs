import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as d,c as p,b as t,d as e,a as o,w as i,e as s}from"./app-0fa68441.js";const c={},h=s(`<h1 id="pipeline-user-guide" tabindex="-1"><a class="header-anchor" href="#pipeline-user-guide" aria-hidden="true">#</a> Pipeline - User Guide</h1><blockquote><p>Overview of what a &quot;pipeline&quot; is</p></blockquote><p>In the Murex docs you&#39;ll often see the term &quot;pipeline&quot;. This refers to any<br> commands sequenced together.</p><p>A pipeline can be joined via any pipe token (eg <code>|</code>, <code>-&gt;</code>, <code>=&gt;</code>, <code>?</code>). But,<br> for the sake of documentation, a pipeline might even be a solitary command.</p><h2 id="examples" tabindex="-1"><a class="header-anchor" href="#examples" aria-hidden="true">#</a> Examples</h2><p>Typical Murex pipeline:</p><pre><code>open: example.json -&gt; [[ /node/0 ]]
</code></pre><p>Example of a single command pipeline:</p><pre><code>top
</code></pre><p>Pipeline you might see in Bash / Zsh (this is also valid in Murex):</p><pre><code>cat names.txt | sort | uniq
</code></pre><p>Pipeline filtering out a specific error from <code>example-cmd</code></p><pre><code>example-cmd ? grep: &quot;File not found&quot;
</code></pre><h2 id="detail" tabindex="-1"><a class="header-anchor" href="#detail" aria-hidden="true">#</a> Detail</h2><p>A pipeline isn&#39;t a Murex specific construct but rather something inherited<br> from Unix. Where Murex differs is that it can support sending typed<br> information to compatible functions (unlike standard Unix pipes which are<br> dumb-byte streams).</p>`,15),u={href:"https://en.wikipedia.org/wiki/Pipeline_(Unix)",target:"_blank",rel:"noopener noreferrer"},m=s('<blockquote><p>In Unix-like computer operating systems, a pipeline is a mechanism for<br> inter-process communication using message passing. A pipeline is a set of<br> processes chained together by their standard streams, so that the output<br> text of each process (stdout) is passed directly as input (stdin) to the<br> next one. The second process is started as the first process is still<br> executing, and they are executed concurrently. The concept of pipelines was<br> championed by Douglas McIlroy at Unix&#39;s ancestral home of Bell Labs, during<br> the development of Unix, shaping its toolbox philosophy. It is named by<br> analogy to a physical pipeline. A key feature of these pipelines is their<br> &quot;hiding of internals&quot; (Ritchie &amp; Thompson, 1974). This in turn allows for<br> more clarity and simplicity in the system.</p></blockquote><h2 id="named-pipes" tabindex="-1"><a class="header-anchor" href="#named-pipes" aria-hidden="true">#</a> Named Pipes</h2><p>The drawback with pipes is that it assumes each command runs sequentially one<br> after another and that everything fits neatly into the concept of &quot;output&quot; and<br> &quot;errors&quot;. The moment you need to use background (<code>bg</code>) processes, do anything<br> more specific with data streams (even if just ignore them entirely), or use<br> more than one data stream, then this concept breaks down. This is where named<br> pipes come to the rescue. Named pipes are out of scope for this specific<br> document but you can read more on them in links the links below.</p><h2 id="see-also" tabindex="-1"><a class="header-anchor" href="#see-also" aria-hidden="true">#</a> See Also</h2>',4),f=t("code",null,"->",-1),b=t("br",null,null,-1),_=t("br",null,null,-1),g=t("code",null,"=>",-1),x=t("br",null,null,-1),y=t("code",null,"|",-1),k=t("br",null,null,-1),T=t("code",null,"?",-1),q=t("br",null,null,-1),w=t("br",null,null,-1),P=t("code",null,"bg",-1),v=t("br",null,null,-1);function S(D,I){const a=r("ExternalLinkIcon"),n=r("RouterLink");return d(),p("div",null,[h,t("p",null,[e("Wikipedia has a page on "),t("a",u,[e("Pipeline (Unix)"),o(a)]),e(":")]),m,t("ul",null,[t("li",null,[o(n,{to:"/parser/pipe-arrow.html"},{default:i(()=>[e("Arrow Pipe ("),f,e(") Token")]),_:1}),e(":"),b,e(" Pipes STDOUT from the left hand command to STDIN of the right hand command")]),t("li",null,[o(n,{to:"/user-guide/bang-prefix.html"},{default:i(()=>[e("Bang Prefix")]),_:1}),e(":"),_,e(" Bang prefixing to reverse default actions")]),t("li",null,[o(n,{to:"/parser/pipe-generic.html"},{default:i(()=>[e("Generic Pipe ("),g,e(") Token")]),_:1}),e(":"),x,e(" Pipes a reformatted STDOUT stream from the left hand command to STDIN of the right hand command")]),t("li",null,[o(n,{to:"/parser/pipe-posix.html"},{default:i(()=>[e("POSIX Pipe ("),y,e(") Token")]),_:1}),e(":"),k,e(" Pipes STDOUT from the left hand command to STDIN of the right hand command")]),t("li",null,[o(n,{to:"/parser/pipe-err.html"},{default:i(()=>[e("STDERR Pipe ("),T,e(") Token")]),_:1}),e(":"),q,e(" Pipes STDERR from the left hand command to STDIN of the right hand command")]),t("li",null,[o(n,{to:"/user-guide/schedulers.html"},{default:i(()=>[e("Schedulers")]),_:1}),e(":"),w,e(" Overview of the different schedulers (or 'run modes') in Murex")]),t("li",null,[o(n,{to:"/commands/bg.html"},{default:i(()=>[P]),_:1}),e(":"),v,e(" Run processes in the background")])])])}const B=l(c,[["render",S],["__file","pipeline.html.vue"]]);export{B as default};
