import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as d,c as l,d as e,b as n,w as o,e as a,f as r}from"./app-dae038b0.js";const c={},h=r(`<h1 id="event" tabindex="-1"><a class="header-anchor" href="#event" aria-hidden="true">#</a> <code>event</code></h1><blockquote><p>Event driven programming for shell scripts</p></blockquote><h2 id="description" tabindex="-1"><a class="header-anchor" href="#description" aria-hidden="true">#</a> Description</h2><p>Create or destroy an event interrupt,</p><p>Each event will have subtilty different behaviour depending on the event itself due to the differing roles of each event system. Therefore it is recommended that you read the docs on each event to understand its behaviour.</p><p>However while they might differ, the <code>event</code> API does try to retain a level of external consistency. For example each event in defined via <code>name=interrupt</code> where <strong>name</strong> is a user defined handle (like a variable or function would have a name) and <strong>interrupt</strong> is a system state you wish the event to be fired on.</p><p>Each event function will have a payload sent via STDIN which would look a little like the following:</p><pre><code>{
    &quot;Name&quot;: &quot;&quot;,
    &quot;Interrupt&quot;: {}
}
</code></pre><p><strong>Name</strong> will always refer to the name you passed when defining the event. And <strong>Interrupt</strong> will carry any event specific metadata that might be useful to the event function. Thus the value of <strong>Interrupt</strong> will vary from one event to another.</p><h2 id="usage" tabindex="-1"><a class="header-anchor" href="#usage" aria-hidden="true">#</a> Usage</h2><pre><code>event: event-type name=interrupt { code block }

!event: event-type name
</code></pre><h2 id="examples" tabindex="-1"><a class="header-anchor" href="#examples" aria-hidden="true">#</a> Examples</h2><p>Create an event:</p><pre><code>event: onSecondsElapsed autoquit=60 {
    out &quot;You&#39;re 60 second timeout has elapsed. Quitting murex&quot;
    exit 1
}
</code></pre><p>Destroy an event:</p><pre><code>!event onSecondsElapsed autoquit
</code></pre><h2 id="detail" tabindex="-1"><a class="header-anchor" href="#detail" aria-hidden="true">#</a> Detail</h2><h3 id="supported-events" tabindex="-1"><a class="header-anchor" href="#supported-events" aria-hidden="true">#</a> Supported events</h3>`,18),u=e("code",null,"onCommandCompletion",-1),p=e("code",null,"onFileSystemChange",-1),m=e("code",null,"onPrompt",-1),f=e("code",null,"onSecondsElapsed",-1),v=r(`<h3 id="ansi-constants" tabindex="-1"><a class="header-anchor" href="#ansi-constants" aria-hidden="true">#</a> ANSI constants</h3><p>The <code>interrupt</code> field in the CLI supports ANSI constants. eg</p><pre><code>event: onKeyPress f1={F1-VT100} {
    tout: qs HintText=&quot;Key F1 Pressed&quot;
}
</code></pre><h3 id="compiled-events" tabindex="-1"><a class="header-anchor" href="#compiled-events" aria-hidden="true">#</a> Compiled events</h3><p>To list compiled event types:</p><pre><code>Â» runtime --events -&gt; formap event ! { out $event }
onCommandCompletion
onFileSystemChange
onKeyPress
onPrompt
onSecondsElapsed
</code></pre><h2 id="synonyms" tabindex="-1"><a class="header-anchor" href="#synonyms" aria-hidden="true">#</a> Synonyms</h2><ul><li><code>event</code></li><li><code>!event</code></li></ul><h2 id="see-also" tabindex="-1"><a class="header-anchor" href="#see-also" aria-hidden="true">#</a> See Also</h2>`,9),_=e("code",null,"formap",-1),g=e("code",null,"function",-1),y=e("code",null,"open",-1),b=e("code",null,"private",-1),x=e("code",null,"runtime",-1);function w(q,S){const t=i("RouterLink");return d(),l("div",null,[h,e("ul",null,[e("li",null,[n(t,{to:"/events/oncommandcompletion.html"},{default:o(()=>[u]),_:1}),a(": Trigger an event upon a command's completion")]),e("li",null,[n(t,{to:"/events/onfilesystemchange.html"},{default:o(()=>[p]),_:1}),a(": Add a filesystem watch")]),e("li",null,[n(t,{to:"/events/onprompt.html"},{default:o(()=>[m]),_:1}),a(": Events triggered by changes in state of the interactive shell")]),e("li",null,[n(t,{to:"/events/onsecondselapsed.html"},{default:o(()=>[f]),_:1}),a(": Events triggered by time intervals")])]),v,e("ul",null,[e("li",null,[n(t,{to:"/commands/formap.html"},{default:o(()=>[_]),_:1}),a(": Iterate through a map or other collection of data")]),e("li",null,[n(t,{to:"/commands/function.html"},{default:o(()=>[g]),_:1}),a(": Define a function block")]),e("li",null,[n(t,{to:"/commands/open.html"},{default:o(()=>[y]),_:1}),a(": Open a file with a preferred handler")]),e("li",null,[n(t,{to:"/commands/private.html"},{default:o(()=>[b]),_:1}),a(": Define a private function block")]),e("li",null,[n(t,{to:"/commands/runtime.html"},{default:o(()=>[x]),_:1}),a(": Returns runtime information on the internal state of Murex")])])])}const E=s(c,[["render",w],["__file","event.html.vue"]]);export{E as default};
