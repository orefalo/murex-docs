import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as i,c as d,d as e,b as r,w as a,e as o,f as s}from"./app-b92fd348.js";const h={},c=s(`<h1 id="posix-pipe-token-parser-reference" tabindex="-1"><a class="header-anchor" href="#posix-pipe-token-parser-reference" aria-hidden="true">#</a> POSIX Pipe (<code>|</code>) Token - Parser Reference</h1><blockquote><p>Pipes STDOUT from the left hand command to STDIN of the right hand command</p></blockquote><h2 id="description" tabindex="-1"><a class="header-anchor" href="#description" aria-hidden="true">#</a> Description</h2><p>This token behaves much like pipe would in Bash or similar shells. It passes STDOUT along the pipeline while merging STDERR stream with the parents STDERR stream.</p><p>It can be used interchangeably with the arrow pipe, <code>-&gt;</code>, in shell scripts.</p><h2 id="examples" tabindex="-1"><a class="header-anchor" href="#examples" aria-hidden="true">#</a> Examples</h2><pre><code>» out: Hello, world! | regexp: s/world/Earth/
Hello, Earth!

» out: Hello, world!|regexp: s/world/Earth/
Hello, Earth!
</code></pre><p>In this example the first command is writing to STDERR rather than STDOUT so <code>Hello, world!</code> doesn&#39;t get pipelined and thus isn&#39;t affected by <code>regexp</code>:</p><pre><code>» err: Hello, world! | regexp: s/world/Earth/
Hello, world!
</code></pre><h2 id="see-also" tabindex="-1"><a class="header-anchor" href="#see-also" aria-hidden="true">#</a> See Also</h2>`,10),p=e("code",null,"->",-1),m=e("code",null,"=>",-1),u=e("code",null,"?",-1),f=e("code",null,"<>",-1),_=e("code",null,"read-named-pipe",-1),T=e("code",null,"err",-1),x=e("code",null,"out",-1),g=e("code",null,"regexp",-1);function w(S,D){const t=l("RouterLink");return i(),d("div",null,[c,e("ul",null,[e("li",null,[r(t,{to:"/parser/pipe-arrow.html"},{default:a(()=>[o("Arrow Pipe ("),p,o(") Token")]),_:1}),o(": Pipes STDOUT from the left hand command to STDIN of the right hand command")]),e("li",null,[r(t,{to:"/parser/pipe-generic.html"},{default:a(()=>[o("Generic Pipe ("),m,o(") Token")]),_:1}),o(": Pipes a reformatted STDOUT stream from the left hand command to STDIN of the right hand command")]),e("li",null,[r(t,{to:"/user-guide/pipeline.html"},{default:a(()=>[o("Pipeline")]),_:1}),o(': Overview of what a "pipeline" is')]),e("li",null,[r(t,{to:"/parser/pipe-err.html"},{default:a(()=>[o("STDERR Pipe ("),u,o(") Token")]),_:1}),o(": Pipes STDERR from the left hand command to STDIN of the right hand command")]),e("li",null,[r(t,{to:"/commands/namedpipe.html"},{default:a(()=>[f,o(" / "),_]),_:1}),o(": Reads from a Murex named pipe")]),e("li",null,[r(t,{to:"/commands/err.html"},{default:a(()=>[T]),_:1}),o(": Print a line to the STDERR")]),e("li",null,[r(t,{to:"/commands/out.html"},{default:a(()=>[x]),_:1}),o(": Print a string to the STDOUT with a trailing new line character")]),e("li",null,[r(t,{to:"/commands/regexp.html"},{default:a(()=>[g]),_:1}),o(": Regexp tools for arrays / lists of strings")])])])}const P=n(h,[["render",w],["__file","pipe-posix.html.vue"]]);export{P as default};
