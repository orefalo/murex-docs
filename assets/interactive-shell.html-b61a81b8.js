import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as h,c as d,d as e,b as i,e as t,w as o,f as l}from"./app-3c4cb7a1.js";const c={},u=l('<h1 id="murex-s-interactive-shell-user-guide" tabindex="-1"><a class="header-anchor" href="#murex-s-interactive-shell-user-guide" aria-hidden="true">#</a> Murex&#39;s Interactive Shell - User Guide</h1><blockquote><p>What&#39;s different about Murex&#39;s interactive shell?</p></blockquote><h2>Table of Contents</h2><div id="toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#readline">readline</a><ul><li><a href="#hotkeys">Hotkeys</a></li><li><a href="#autocompletion">Autocompletion</a></li><li><a href="#syntax-completion">Syntax Completion</a></li><li><a href="#syntax-highlighting">Syntax Highlighting</a></li><li><a href="#spellchecker">Spellchecker</a></li><li><a href="#hint-text">Hint Text</a><ul><li><a href="#configuring-hint-text-colour">Configuring Hint Text Colour</a></li></ul></li><li><a href="#custom-hint-text-statuses">Custom Hint Text Statuses</a><ul><li><a href="#disabling-hint-text">Disabling Hint Text</a></li></ul></li></ul></li></ul></div><h2 id="overview" tabindex="-1"><a class="header-anchor" href="#overview" aria-hidden="true">#</a> Overview</h2><p>Aside from Murex being carefully designed with scripting in mind, the<br> interactive shell itself is also built around productivity. To achieve this<br> we wrote our own readline library. Below is an example of that library in use:</p>',6),p={href:"https://asciinema.org/a/232714",target:"_blank",rel:"noopener noreferrer"},g=e("img",{src:"https://asciinema.org/a/232714.svg",alt:"asciicast",loading:"lazy"},null,-1),f=l('<p>The above demo includes the following features of Murex&#39;s bespoke readline<br> library:</p><ul><li>hint text - blue status text below the prompt (the colour is configurable)</li><li>syntax highlighting (albeit there isn’t much syntax to highlight in the<br> example). This can also be turned off if your preference is to have colours<br> disabled</li><li>tab-completion in gridded mode (seen when typing <code>cd</code>)</li><li>tab-completion in list view (seen when selecting a process name to <code>kill</code><br> where the process ID was substituted when selected)</li><li>searching through the tab-completion suggestions (seen in both <code>cd</code> and<br><code>kill</code> - enabled by pressing <code>[ctrl]</code>+<code>[f]</code>)</li><li>line editing using $EDITOR (<code>vi</code> in the example - enabled by pressing <code>[esc]</code><br> followed by <code>[v]</code>)</li><li>readline’s warning before pasting multiple lines of data into the buffer and<br> the preview option that’s available as part of the aforementioned warning</li><li>and VIM keys (enabled by pressing <code>[esc]</code>)</li></ul><h2 id="readline" tabindex="-1"><a class="header-anchor" href="#readline" aria-hidden="true">#</a> readline</h2><p>Murex uses a custom <code>readline</code> library to enable support for new features on<br> in addition to the existing uses you&#39;d normally expect from a shell. It is<br> because of this Murex provides one of the best user experiences of any of the<br> shells available today.</p><h3 id="hotkeys" tabindex="-1"><a class="header-anchor" href="#hotkeys" aria-hidden="true">#</a> Hotkeys</h3>',5),m=e("h3",{id:"autocompletion",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#autocompletion","aria-hidden":"true"},"#"),t(" Autocompletion")],-1),b=e("code",null,"[tab]",-1),_=e("br",null,null,-1),x=e("code",null,"autocomplete",-1),y=e("br",null,null,-1),w=e("code",null,"|",-1),k=e("br",null,null,-1),v=e("code",null,"->",-1),T=l(`<p>The <code>|</code> token will behave much like any other shell however <code>-&gt;</code> will offer<br> suggestions with matching data types (as seen in <code>runtime --methods</code>). This is<br> a way of helping highlight commands that naturally follow after another in a<br> pipeline. Which is particularly important in Murex as it introduces data<br> types and dozens of new builtins specifically for working with data structures<br> in an intelligent and readable yet succinct way.</p><p>You can add your own commands and functions to Murex as methods by defining<br> them with <code>method</code>. For example if we were to add <code>jq</code> as a method:</p><pre><code>method: define jq {
    &quot;Stdin&quot;:  &quot;json&quot;,
    &quot;Stdout&quot;: &quot;@Any&quot;
}
</code></pre><h3 id="syntax-completion" tabindex="-1"><a class="header-anchor" href="#syntax-completion" aria-hidden="true">#</a> Syntax Completion</h3><p>Like with most IDEs, Murex will auto close brackets et al.</p>`,5),S={href:"https://asciinema.org/a/408029",target:"_blank",rel:"noopener noreferrer"},I=e("img",{src:"https://asciinema.org/a/408029.svg",alt:"asciicast",loading:"lazy"},null,-1),q=e("h3",{id:"syntax-highlighting",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#syntax-highlighting","aria-hidden":"true"},"#"),t(" Syntax Highlighting")],-1),M=e("p",null,[t("Pipelines in the interactive terminal are syntax highlighted. This is similar"),e("br"),t(" to what one expects from an IDE.")],-1),C=e("p",null,"Syntax highlighting can be disabled by running:",-1),H=e("pre",null,[e("code",null,`» config: set shell syntax-highlighting off
`)],-1),A=e("h3",{id:"spellchecker",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#spellchecker","aria-hidden":"true"},"#"),t(" Spellchecker")],-1),D=e("p",null,"Murex supports inline spellchecking, where errors are underlined. For example",-1),N={href:"https://asciinema.org/a/408024",target:"_blank",rel:"noopener noreferrer"},B=e("img",{src:"https://asciinema.org/a/408024.svg",alt:"asciicast",loading:"lazy"},null,-1),O=e("br",null,null,-1),P=l(`<h3 id="hint-text" tabindex="-1"><a class="header-anchor" href="#hint-text" aria-hidden="true">#</a> Hint Text</h3><p>The <strong>hint text</strong> is a (typically) blue status line that appears directly below<br> your prompt. The idea behind the <strong>hint text</strong> is to provide clues to you as<br> type instructions into the prompt; but without adding distractions. It is there<br> to be used if you want it while keeping out of the way when you don&#39;t want it.</p><h4 id="configuring-hint-text-colour" tabindex="-1"><a class="header-anchor" href="#configuring-hint-text-colour" aria-hidden="true">#</a> Configuring Hint Text Colour</h4><p>By default the <strong>hint text</strong> will appear blue. This is also customizable:</p><pre><code>» config get shell hint-text-formatting
{BLUE}
</code></pre>`,5),E=l(`<p>It is also worth noting that if colour is disabled then the <strong>hint text</strong> will<br> not be coloured even if <strong>hint-text-formatting</strong> includes colour codes:</p><pre><code>» config: set shell color false
</code></pre><p>(please note that <strong>syntax highlighting</strong> is unaffected by the above config)</p><h3 id="custom-hint-text-statuses" tabindex="-1"><a class="header-anchor" href="#custom-hint-text-statuses" aria-hidden="true">#</a> Custom Hint Text Statuses</h3><p>There is a lot of behavior hardcoded into Murex like displaying the full path<br> to executables and the values of variables. However if there is no status to be<br> displayed then Murex can fallback to a default <strong>hint text</strong> status. This<br> default is a user defined function. At time of writing this document the author<br> has the following function defined:</p><pre><code>config: set shell hint-text-func {
    trypipe &lt;!null&gt; {
        git status --porcelain -b -&gt; set gitstatus
        $gitstatus -&gt; head -n1 -&gt; regexp &#39;s/^## //&#39; -&gt; regexp &#39;s/\\.\\.\\./ =&gt; /&#39;
    }
    catch {
        out &quot;Not a git repository.&quot;
    }
}
</code></pre><p>...which produces a colorized status that looks something like the following:</p><pre><code>develop =&gt; origin/develop
</code></pre><h4 id="disabling-hint-text" tabindex="-1"><a class="header-anchor" href="#disabling-hint-text" aria-hidden="true">#</a> Disabling Hint Text</h4><p>It is enabled by default but can be disabled if you prefer a more minimal<br> prompt:</p><pre><code>» config: set shell hint-text-enabled false
</code></pre><h2 id="see-also" tabindex="-1"><a class="header-anchor" href="#see-also" aria-hidden="true">#</a> See Also</h2>`,12),z=e("br",null,null,-1),L=e("code",null,"->",-1),V=e("br",null,null,-1),R=e("br",null,null,-1),U=e("code",null,"{",-1),j=e("code",null,"}",-1),F=e("br",null,null,-1),W=e("code",null,"|",-1),X=e("br",null,null,-1),$=e("br",null,null,-1),G=e("code",null,"autocomplete",-1),Q=e("br",null,null,-1),Y=e("code",null,"config",-1),J=e("br",null,null,-1),K=e("code",null,"method",-1),Z=e("br",null,null,-1),ee=e("code",null,"runtime",-1),te=e("br",null,null,-1);function ie(ne,oe){const a=s("ExternalLinkIcon"),n=s("RouterLink");return h(),d("div",null,[u,e("p",null,[e("a",p,[g,i(a)])]),f,e("p",null,[t("A full breakdown of supported hotkeys is available at "),i(n,{to:"/user-guide/terminal-keys.html"},{default:o(()=>[t("terminal-keys.md")]),_:1}),t(".")]),m,e("p",null,[t("Autocompletion happen when you press "),b,t(" and will differ slightly depending"),_,t(" on what is defined in "),x,t(" and whether you use the traditional"),y,i(n,{to:"/parser/pipe-posix.html"},{default:o(()=>[t("POSIX pipe token")]),_:1}),t(", "),w,t(", or the "),i(n,{to:"/parser/pipe-arrow.html"},{default:o(()=>[t("arrow pipe")]),_:1}),t(","),k,v,t(".")]),T,e("p",null,[e("a",S,[I,i(a)])]),q,M,C,H,A,D,e("p",null,[e("a",N,[B,i(a)])]),e("p",null,[t("This might require some manual steps to enable, please see the "),i(n,{to:"/user-guide/spellcheck.html"},{default:o(()=>[t("spellcheck user guide")]),_:1}),O,t(" for more details.")]),P,e("p",null,[t("The formatting config takes a string and supports "),i(n,{to:"/user-guide/ansi.html"},{default:o(()=>[t("ANSI constants")]),_:1}),t(".")]),E,e("ul",null,[e("li",null,[i(n,{to:"/user-guide/ansi.html"},{default:o(()=>[t("ANSI Constants")]),_:1}),t(":"),z,t(" Infixed constants that return ANSI escape sequences")]),e("li",null,[i(n,{to:"/parser/pipe-arrow.html"},{default:o(()=>[t("Arrow Pipe ("),L,t(") Token")]),_:1}),t(":"),V,t(" Pipes STDOUT from the left hand command to STDIN of the right hand command")]),e("li",null,[i(n,{to:"/user-guide/code-block.html"},{default:o(()=>[t("Code Block Parsing")]),_:1}),t(":"),R,t(" Overview of how code blocks are parsed")]),e("li",null,[i(n,{to:"/parser/curly-brace.html"},{default:o(()=>[t("Curly Brace ("),U,t(", "),j,t(") Tokens")]),_:1}),t(":"),F,t(" Initiates or terminates a code block")]),e("li",null,[i(n,{to:"/parser/pipe-posix.html"},{default:o(()=>[t("POSIX Pipe ("),W,t(") Token")]),_:1}),t(":"),X,t(" Pipes STDOUT from the left hand command to STDIN of the right hand command")]),e("li",null,[i(n,{to:"/user-guide/spellcheck.html"},{default:o(()=>[t("Spellcheck")]),_:1}),t(":"),$,t(" How to enable inline spellchecking")]),e("li",null,[i(n,{to:"/commands/autocomplete.html"},{default:o(()=>[G]),_:1}),t(":"),Q,t(" Set definitions for tab-completion in the command line")]),e("li",null,[i(n,{to:"/commands/config.html"},{default:o(()=>[Y]),_:1}),t(":"),J,t(" Query or define Murex runtime settings")]),e("li",null,[i(n,{to:"/commands/method.html"},{default:o(()=>[K]),_:1}),t(":"),Z,t(" Define a methods supported data-types")]),e("li",null,[i(n,{to:"/commands/runtime.html"},{default:o(()=>[ee]),_:1}),t(":"),te,t(" Returns runtime information on the internal state of Murex")])])])}const se=r(c,[["render",ie],["__file","interactive-shell.html.vue"]]);export{se as default};
