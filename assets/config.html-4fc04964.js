import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as r,c,d as e,b as a,w as n,e as t,f as i}from"./app-dae038b0.js";const l={},u=i(`<h1 id="config" tabindex="-1"><a class="header-anchor" href="#config" aria-hidden="true">#</a> <code>config</code></h1><blockquote><p>Query or define Murex runtime settings</p></blockquote><h2 id="description" tabindex="-1"><a class="header-anchor" href="#description" aria-hidden="true">#</a> Description</h2><p>Rather than Murex runtime settings being definable via obscure environmental variables, Murex instead supports a registry of config defined via the <code>config</code> command. This means any preferences and/or runtime config becomes centralised and discoverable.</p><h2 id="usage" tabindex="-1"><a class="header-anchor" href="#usage" aria-hidden="true">#</a> Usage</h2><p>List all settings:</p><pre><code>config -&gt; \`&lt;stdout&gt;\`
</code></pre><p>Get a setting:</p><pre><code>config get app key -&gt; \`&lt;stdout&gt;\`
</code></pre><p>Set a setting:</p><pre><code>config set app key value

\`&lt;stdin&gt;\` -&gt; config set app key

config eval app key { -&gt; code-block }
</code></pre><p>Define a new config setting:</p><pre><code>config define app key { mxjson }
</code></pre><p>Reset a setting to it&#39;s default value:</p><pre><code>!config app key

config default app key
</code></pre><h2 id="examples" tabindex="-1"><a class="header-anchor" href="#examples" aria-hidden="true">#</a> Examples</h2><p>Using <code>eval</code> to append to an array (in this instance, adding a function name to the list of &quot;safe&quot; commands)</p><pre><code>» function: foobar { -&gt; match foobar }
» config: eval shell safe-commands { -&gt; append foobar }
</code></pre><h2 id="detail" tabindex="-1"><a class="header-anchor" href="#detail" aria-hidden="true">#</a> Detail</h2><p>With regards to <code>config</code>, the following terms are applied:</p><h3 id="app" tabindex="-1"><a class="header-anchor" href="#app" aria-hidden="true">#</a> &quot;app&quot;</h3><p>This refers to a grouped category of settings. For example the name of a built in.</p><p>Other app names include</p><ul><li><code>shell</code>: for &quot;global&quot; (system wide) Murex settings</li><li><code>proc</code>: for scoped Murex settings</li><li><code>http</code>: for settings that are applied to any processes which use the builtin HTTP user agent (eg <code>open</code>, <code>get</code>, <code>getfile</code>, <code>post</code>)</li><li><code>test</code>: settings for Murex&#39;s test frameworks</li><li><code>index</code>: settings for <code>[</code> (index)</li></ul><h3 id="key" tabindex="-1"><a class="header-anchor" href="#key" aria-hidden="true">#</a> &quot;key&quot;</h3><p>This refers to the config setting itself. For example the &quot;app&quot; might be <code>http</code> but the &quot;key&quot; might be <code>timeout</code> - where the &quot;key&quot;, in this instance, holds the value for how long any HTTP user agents might wait before timing out.</p><h3 id="value" tabindex="-1"><a class="header-anchor" href="#value" aria-hidden="true">#</a> &quot;value&quot;</h3><p>Value is the actual value of a setting. So the value for &quot;app&quot;: <code>http</code>, &quot;key&quot;: <code>timeout</code> might be <code>10</code>. eg</p><pre><code>» config get http timeout
10
</code></pre><h3 id="scope-scoped" tabindex="-1"><a class="header-anchor" href="#scope-scoped" aria-hidden="true">#</a> &quot;scope&quot; / &quot;scoped&quot;</h3><p>Settings in <code>config</code>, by default, are scoped per function and module. Any functions called will inherit the settings of it&#39;s caller parent. However any child functions that then change the settings will only change settings for it&#39;s own function and not the parent caller.</p><p>Please note that <code>config</code> settings are scoped differently to local variables.</p><h3 id="global" tabindex="-1"><a class="header-anchor" href="#global" aria-hidden="true">#</a> &quot;global&quot;</h3><p>Global settings defined inside a function will affect settings queried inside another executing function (same concept as global variables).</p><h2 id="directives" tabindex="-1"><a class="header-anchor" href="#directives" aria-hidden="true">#</a> Directives</h2><p>The directives for <code>config define</code> are listed below. Headings are formatted as follows:</p><pre><code>&quot;DirectiveName&quot;: json data-type (default value)
</code></pre><p>Where &quot;default value&quot; is what will be auto-populated if you don&#39;t include that directive (or &quot;required&quot; if the directive must be included).</p><h3 id="datatype-string-required" tabindex="-1"><a class="header-anchor" href="#datatype-string-required" aria-hidden="true">#</a> &quot;DataType&quot;: string (required)</h3><p>This is the Murex data-type for the value.</p><h3 id="description-string-required" tabindex="-1"><a class="header-anchor" href="#description-string-required" aria-hidden="true">#</a> &quot;Description&quot;: string (required)</h3><p>Description is a required field to force developers into writing meaning hints enabling the discoverability of settings within Murex.</p><h3 id="global-boolean-false" tabindex="-1"><a class="header-anchor" href="#global-boolean-false" aria-hidden="true">#</a> &quot;Global&quot;: boolean (false)</h3><p>This defines whether this setting is global or scoped.</p><p>All <strong>Dynamic</strong> settings <em>must</em> also be <strong>Global</strong>. This is because <strong>Dynamic</strong> settings rely on a state that likely isn&#39;t scoped (eg the contents of a config file).</p><h3 id="default-any-required" tabindex="-1"><a class="header-anchor" href="#default-any-required" aria-hidden="true">#</a> &quot;Default&quot;: any (required)</h3><p>This is the initialized and default value.</p><h3 id="options-array-nil" tabindex="-1"><a class="header-anchor" href="#options-array-nil" aria-hidden="true">#</a> &quot;Options&quot;: array (nil)</h3><p>Some suggested options (if known) to provide as autocompletion suggestions in the interactive command line.</p><h3 id="dynamic-map-of-strings-nil" tabindex="-1"><a class="header-anchor" href="#dynamic-map-of-strings-nil" aria-hidden="true">#</a> &quot;Dynamic&quot;: map of strings (nil)</h3><p>Only use this if config options need to be more than just static values stored inside Murex&#39;s runtime. Using <strong>Dynamic</strong> means <code>autocomplete get app key</code> and <code>autocomplete set app key value</code> will spawn off a subshell running a code block defined from the <code>Read</code> and <code>Write</code> mapped values. eg</p><pre><code># Create the example config file
(this is the default value) -&gt; &gt; example.conf

# mxjson format, so we can have comments and block quotes: #, (, )
config define example test ({
    &quot;Description&quot;: &quot;This is only an example&quot;,
    &quot;DataType&quot;: &quot;str&quot;,
    &quot;Global&quot;: true,
    &quot;Dynamic&quot;: {
        &quot;Read&quot;: ({
            open example.conf
        }),
        &quot;Write&quot;: ({
            -&gt; &gt; example.conf
        })
    },
    # read the config file to get the default value
    &quot;Default&quot;: &quot;\${open example.conf}&quot;
})
</code></pre><p>It&#39;s also worth noting the different syntax between <strong>Read</strong> and <strong>Default</strong>. The <strong>Read</strong> code block is being executed when the <strong>Read</strong> directive is being requested, whereas the <strong>Default</strong> code block is being executed when the JSON is being read.</p><p>In technical terms, the <strong>Default</strong> code block is being executed by Murex when <code>config define</code> is getting executed where as the <strong>Read</strong> and <strong>Write</strong> code blocks are getting stored as a JSON string and then executed only when those hooks are getting triggered.</p><p>See the <code>mxjson</code> data-type for more details.</p>`,55),h=e("h3",{"Read:string()":"",id:"dynamic",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#dynamic","aria-hidden":"true"},"#"),t(' "Dynamic":')],-1),p=e("p",null,[t("This is executed when "),e("code",null,"autocomplete get app key"),t(" is ran. The STDOUT of the code block is the setting's value.")],-1),f=e("h3",{"Write:string()":"",id:"dynamic-1",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#dynamic-1","aria-hidden":"true"},"#"),t(' "Dynamic":')],-1),g=i('<p>This is executed when <code>autocomplete</code> is setting a value (eg <code>set</code>, <code>default</code>, <code>eval</code>). is ran. The STDIN of the code block is the new value.</p><h2 id="synonyms" tabindex="-1"><a class="header-anchor" href="#synonyms" aria-hidden="true">#</a> Synonyms</h2><ul><li><code>config</code></li><li><code>!config</code></li></ul><h2 id="see-also" tabindex="-1"><a class="header-anchor" href="#see-also" aria-hidden="true">#</a> See Also</h2>',4),m=e("code",null,"[[",-1),b=e("code",null,"[",-1),q=e("code",null,"append",-1),y=e("code",null,"event",-1),x=e("code",null,"function",-1),_=e("code",null,"get",-1),v=e("code",null,"getfile",-1),w=e("code",null,"match",-1),k=e("code",null,"open",-1),T=e("code",null,"post",-1),D=e("code",null,"runtime",-1);function M(S,O){const o=s("RouterLink");return r(),c("div",null,[u,h,p,f,g,e("ul",null,[e("li",null,[a(o,{to:"/commands/element.html"},{default:n(()=>[m,t(" (element)")]),_:1}),t(": Outputs an element from a nested structure")]),e("li",null,[a(o,{to:"/commands/index2.html"},{default:n(()=>[b,t(" (index)")]),_:1}),t(": Outputs an element from an array, map or table")]),e("li",null,[a(o,{to:"/commands/append.html"},{default:n(()=>[q]),_:1}),t(": Add data to the end of an array")]),e("li",null,[a(o,{to:"/commands/event.html"},{default:n(()=>[y]),_:1}),t(": Event driven programming for shell scripts")]),e("li",null,[a(o,{to:"/commands/function.html"},{default:n(()=>[x]),_:1}),t(": Define a function block")]),e("li",null,[a(o,{to:"/commands/get.html"},{default:n(()=>[_]),_:1}),t(": Makes a standard HTTP request and returns the result as a JSON object")]),e("li",null,[a(o,{to:"/commands/getfile.html"},{default:n(()=>[v]),_:1}),t(": Makes a standard HTTP request and return the contents as Murex-aware data type for passing along Murex pipelines.")]),e("li",null,[a(o,{to:"/commands/match.html"},{default:n(()=>[w]),_:1}),t(": Match an exact value in an array")]),e("li",null,[a(o,{to:"/commands/open.html"},{default:n(()=>[k]),_:1}),t(": Open a file with a preferred handler")]),e("li",null,[a(o,{to:"/commands/post.html"},{default:n(()=>[T]),_:1}),t(": HTTP POST request with a JSON-parsable return")]),e("li",null,[a(o,{to:"/commands/runtime.html"},{default:n(()=>[D]),_:1}),t(": Returns runtime information on the internal state of Murex")]),e("li",null,[a(o,{to:"/types/mxjson.html"},{default:n(()=>[t("mxjson")]),_:1}),t(": Murex-flavoured JSON (deprecated)")])])])}const j=d(l,[["render",M],["__file","config.html.vue"]]);export{j as default};
